# THIS FILE WAS AUTO-GENERATED BY THE FLOWORK CORE COMPILER
from flowork_kernel.services.base_service import BaseService
import os
import json
import importlib.util
import shutil
import datetime
class FormatterManagerService(BaseService):
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
    def get_formatter(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: get_formatter ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # This node replicates the logic of FormatterManagerService.get_formatter()
                # It receives the formatter_id as input and returns an instance of the formatter class.
                
                # Import the necessary library for dynamic loading
                import importlib.util
                
                # Get formatter_id from the arguments passed to the method call
                formatter_id = args[0] if args else None
                if not formatter_id:
                    log('FormatterManagerWorkflow: formatter_id was not provided.', 'ERROR')
                    return None
                
                formatters_path = os.path.join(kernel.project_root_path, "formatters")
                formatter_dir = os.path.join(formatters_path, formatter_id)
                
                if not os.path.isdir(formatter_dir):
                    log(f'FormatterManagerWorkflow: Formatter directory not found for {formatter_id}', 'WARN')
                    return None
                
                manifest_path = os.path.join(formatter_dir, "manifest.json")
                if not os.path.exists(manifest_path):
                    log(f'FormatterManagerWorkflow: manifest.json not found for {formatter_id}', 'WARN')
                    return None
                
                try:
                    with open(manifest_path, 'r', encoding='utf-8') as f:
                        manifest = json.load(f)
                    
                    entry_point = manifest.get("entry_point")
                    if not entry_point:
                        return None
                
                    module_filename, class_name = entry_point.split('.')
                    source_file = os.path.join(formatter_dir, f"{module_filename}.py")
                
                    # Dynamically load the module and class
                    spec = importlib.util.spec_from_file_location(f"formatters.{formatter_id}", source_file)
                    module_lib = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(module_lib)
                    FormatterClass = getattr(module_lib, class_name)
                    
                    # Return an instance of the class
                    return FormatterClass()
                
                except Exception as e:
                    log(f'FormatterManagerWorkflow: Failed to load formatter {formatter_id}: {e}', 'ERROR')
                    return None
            node_results['get_formatter_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node get_formatter: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('get_formatter_node')
