# THIS FILE WAS AUTO-GENERATED BY THE FLOWORK CORE COMPILER
from flowork_kernel.services.base_service import BaseService
import os
import json
import importlib.util
import shutil
import datetime
class PresetManagerService(BaseService):
    def __init__(self, kernel, service_id: str):
        super().__init__(kernel, service_id)
        self.logger = self.kernel.write_to_log
    def save_preset(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: save_preset ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # This function saves workflow data to a .json file.
                preset_name = args[0] if len(args) > 0 else None
                workflow_data = args[1] if len(args) > 1 else None
                if not preset_name or not workflow_data:
                    log("PresetManagerWorkflow(save_preset): Missing preset name or data.", "ERROR")
                    return False
                
                presets_dir = os.path.join(kernel.data_path, "presets")
                versions_dir = os.path.join(presets_dir, "__versions__", preset_name)
                os.makedirs(versions_dir, exist_ok=True)
                
                filepath = os.path.join(presets_dir, f"{preset_name}.json")
                
                # Backup existing file to versions
                if os.path.exists(filepath):
                    try:
                        timestamp = datetime.datetime.now().strftime('%Y%m%d_%H%M%S')
                        backup_path = os.path.join(versions_dir, f"{timestamp}.jsonbak")
                        shutil.copyfile(filepath, backup_path)
                        log(f'PresetManagerWorkflow: Backed up old version of {preset_name} to {backup_path}', 'INFO')
                    except Exception as e:
                        log(f'PresetManagerWorkflow: Failed to back up preset version for {preset_name}: {e}', 'WARN')
                
                # Save the new file
                try:
                    with open(filepath, 'w', encoding='utf-8') as f:
                        json.dump(workflow_data, f, indent=4)
                    return True
                except Exception as e:
                    log(f"PresetManagerWorkflow(save_preset): Error saving preset {preset_name}: {e}", "ERROR")
                    return False
            node_results['save_preset_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node save_preset: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('save_preset_node')

    def get_preset_data(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: get_preset_data ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # This function reads the content of a specific preset JSON file.
                preset_name = args[0] if args else None
                if not preset_name:
                    return None
                filepath = os.path.join(kernel.data_path, "presets", f"{preset_name}.json")
                if not os.path.exists(filepath):
                    return None
                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        return json.load(f)
                except Exception as e:
                    log(f"PresetManagerWorkflow(get_preset_data): Error - {e}", "ERROR")
                    return None
            node_results['get_preset_data_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node get_preset_data: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('get_preset_data_node')

    def load_preset_version(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: load_preset_version ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # ADDED: This node loads the content of a specific version file.
                preset_name = args[0] if len(args) > 0 else None
                version_filename = args[1] if len(args) > 1 else None
                if not preset_name or not version_filename:
                    return None
                version_path = os.path.join(kernel.data_path, "presets", "__versions__", preset_name, version_filename)
                if not os.path.exists(version_path):
                    return None
                try:
                    with open(version_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
                except Exception as e:
                    log(f'PresetManagerWorkflow(load_preset_version): Error - {e}', 'ERROR')
                    return None
            node_results['load_preset_version_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node load_preset_version: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('load_preset_version_node')

    def get_preset_versions(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: get_preset_versions ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # ADDED: This node lists all backed up versions for a preset.
                preset_name = args[0] if args else None
                if not preset_name:
                    return []
                versions_dir = os.path.join(kernel.data_path, "presets", "__versions__", preset_name)
                if not os.path.isdir(versions_dir):
                    return []
                try:
                    version_files = [f for f in os.listdir(versions_dir) if f.endswith('.jsonbak')]
                    version_data = []
                    for filename in version_files:
                        timestamp_str = filename.replace('.jsonbak', '')
                        version_data.append({'filename': filename, 'timestamp': timestamp_str})
                    # Sort by timestamp descending (newest first)
                    return sorted(version_data, key=lambda x: x['timestamp'], reverse=True)
                except Exception as e:
                    log(f'PresetManagerWorkflow(get_preset_versions): Error - {e}', 'ERROR')
                    return []
            node_results['get_preset_versions_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node get_preset_versions: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('get_preset_versions_node')

    def get_preset_list(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: get_preset_list ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # This function lists all .json files in the presets directory.
                presets_dir = os.path.join(kernel.data_path, "presets")
                if not os.path.isdir(presets_dir):
                    os.makedirs(presets_dir)
                    return []
                try:
                    presets = [f.replace('.json', '') for f in os.listdir(presets_dir) if f.endswith('.json') and not f.startswith('__')]
                    return sorted(presets)
                except Exception as e:
                    log(f"PresetManagerWorkflow(get_preset_list): Error - {e}", "ERROR")
                    return []
            node_results['get_preset_list_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node get_preset_list: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('get_preset_list_node')

    def delete_preset(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: delete_preset ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # This function deletes a preset file and its versions.
                preset_name = args[0] if args else None
                if not preset_name:
                    return False
                
                presets_dir = os.path.join(kernel.data_path, "presets")
                filepath = os.path.join(presets_dir, f"{preset_name}.json")
                versions_dir = os.path.join(presets_dir, "__versions__", preset_name)
                
                file_deleted = False
                if os.path.exists(filepath):
                    try:
                        os.remove(filepath)
                        file_deleted = True
                    except Exception as e:
                        log(f'PresetManagerWorkflow(delete_preset): Could not delete main file for {preset_name}: {e}', 'ERROR')
                
                if os.path.isdir(versions_dir):
                    try:
                        shutil.rmtree(versions_dir)
                    except Exception as e:
                        log(f'PresetManagerWorkflow(delete_preset): Could not delete versions for {preset_name}: {e}', 'ERROR')
                
                return file_deleted
            node_results['delete_preset_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node delete_preset: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('delete_preset_node')

    def delete_preset_version(self, *args, **kwargs):
        # This entire method was translated from a visual workflow.
        kernel = self.kernel
        log = self.logger
        payload = {'data': {'args': args, 'kwargs': kwargs}, 'history': []}
        # Dictionary to store results of each node
        node_results = {}

        # --- Executing Node: delete_preset_version ---
        try:
            current_payload = payload
            def temp_func(payload, log, kernel, args, json, os, importlib):
                # ADDED: This node deletes a specific version file.
                preset_name = args[0] if len(args) > 0 else None
                version_filename = args[1] if len(args) > 1 else None
                if not preset_name or not version_filename:
                    return False
                version_path = os.path.join(kernel.data_path, "presets", "__versions__", preset_name, version_filename)
                if os.path.exists(version_path):
                    try:
                        os.remove(version_path)
                        return True
                    except Exception as e:
                        log(f'PresetManagerWorkflow(delete_preset_version): Error - {e}', 'ERROR')
                        return False
                return False
            node_results['delete_preset_version_node'] = temp_func(current_payload, log, kernel, current_payload.get('data',{}).get('args', []), json, os, importlib.util)
        except Exception as e:
            self.logger(f'Error executing node delete_preset_version: {e}', 'ERROR')
            return None # Or handle error appropriately

        # Return the result from the final node in the flow
        return node_results.get('delete_preset_version_node')
