#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE WWW.TEETAH.ART
# File NAME : C:\FLOWORK\modules\encode_base64_text_1998\processor.py
# JUMLAH BARIS : 69
#######################################################################

from flowork_kernel.api_contract import BaseModule, IExecutable, IConfigurableUI, IDataPreviewer
from flowork_kernel.ui_shell import shared_properties
from flowork_kernel.utils.payload_helper import get_nested_value
from flowork_kernel.ui_shell.components.LabelledCombobox import LabelledCombobox
import ttkbootstrap as ttk
from tkinter import StringVar
import base64
class EncodeBase64Text1998Module(BaseModule, IExecutable, IConfigurableUI, IDataPreviewer):
    TIER = "free"
    """
    Module 'Encode Base64 Text' generated by Flowork Module Factory.
    Author: AWENK AUDICO
    """
    def __init__(self, module_id, services):
        super().__init__(module_id, services)
    def execute(self, payload: dict, config: dict, status_updater, ui_callback, mode='EXECUTE'):
        text_to_encode_path = config.get('text_to_encode', '')
        text_to_encode = get_nested_value(payload, text_to_encode_path)
        if not text_to_encode or not isinstance(text_to_encode, str):
            error_msg = f"Input text not found or is not a string at payload path: '{text_to_encode_path}'"
            status_updater(error_msg, "ERROR")
            payload['error'] = error_msg
            return {"payload": payload, "output_name": "error"}
        try:
            encoded_bytes = base64.b64encode(str(text_to_encode).encode('utf-8')) # Ensure value is string before encoding
            encoded_string = encoded_bytes.decode('utf-8')
            if 'data' not in payload or not isinstance(payload['data'], dict):
                payload['data'] = {}
            payload['data']['encoded_text'] = encoded_string
            status_updater("Encoding successful", "SUCCESS")
            return {"payload": payload, "output_name": "success"}
        except Exception as e:
            error_msg = f"Failed to encode text: {e}"
            self.logger(error_msg, "ERROR")
            payload['error'] = error_msg
            return {"payload": payload, "output_name": "error"}
    def create_properties_ui(self, parent_frame, get_current_config, available_vars):
        config = get_current_config()
        property_vars = {}
        property_vars['text_to_encode'] = StringVar(value=config.get('text_to_encode', ''))
        LabelledCombobox(
            parent=parent_frame,
            label_text="Text to Encode (from variable):",
            variable=property_vars['text_to_encode'],
            values=list(available_vars.keys())
        )
        ttk.Separator(parent_frame).pack(fill='x', pady=15, padx=5)
        debug_vars = shared_properties.create_debug_and_reliability_ui(parent_frame, config, self.loc)
        property_vars.update(debug_vars)
        loop_vars = shared_properties.create_loop_settings_ui(parent_frame, config, self.loc, available_vars)
        property_vars.update(loop_vars)
        return property_vars
    def get_data_preview(self, config: dict):
        return [{'status': 'preview not implemented'}]
    def get_dynamic_output_schema(self, config):
        return [
            {
                "name": "data.encoded_text",
                "type": "string",
                "description": "The Base64 encoded result of the input text."
            }
        ]
