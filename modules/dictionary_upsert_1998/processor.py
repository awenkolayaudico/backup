#######################################################################
# dev : awenk audico
# EMAIL SAHIDINAOLA@GMAIL.COM
# WEBSITE WWW.TEETAH.ART
# File NAME : C:\FLOWORK\modules\dictionary_upsert_1998\processor.py
# JUMLAH BARIS : 61
#######################################################################

from flowork_kernel.api_contract import BaseModule, IExecutable, IConfigurableUI, IDataPreviewer
from flowork_kernel.ui_shell import shared_properties
from flowork_kernel.utils.payload_helper import get_nested_value
import ttkbootstrap as ttk
from tkinter import StringVar
class DictionaryUpsert1998Module(BaseModule, IExecutable, IConfigurableUI, IDataPreviewer):
    TIER = "free"
    """
    Module 'Dictionary Upsert' generated by Flowork Module Factory.
    Author: Flowork Contributor
    """
    def __init__(self, module_id, services):
        super().__init__(module_id, services)
        self.logger("Module 'Dictionary Upsert' initialized.", "INFO")
    def execute(self, payload: dict, config: dict, status_updater, ui_callback, mode='EXECUTE'):
        self.logger("Executing 'Dictionary Upsert' module logic...", "INFO")
        dict_path = config.get('target_dictionary_path', '')
        key = get_nested_value(payload, config.get('key_to_upsert', ''))
        value = get_nested_value(payload, config.get('value_to_upsert', ''))
        try:
            target_dict = get_nested_value(payload, dict_path)
            if not isinstance(target_dict, dict):
                raise TypeError(f"Target at path '{dict_path}' is not a dictionary.")
            target_dict[key] = value
            if 'data' not in payload or not isinstance(payload['data'], dict):
                payload['data'] = {}
            payload['data']['updated_dictionary'] = target_dict
            status_updater(f"Key '{key}' was set in dictionary.", "SUCCESS")
            return {"payload": payload, "output_name": "success"}
        except Exception as e:
            error_msg = f"Failed to upsert into dictionary: {e}"
            self.logger(error_msg, "ERROR")
            payload['error'] = error_msg
            return {"payload": payload, "output_name": "error"}
    def create_properties_ui(self, parent_frame, get_current_config, available_vars):
        config = get_current_config()
        property_vars = {}
        property_vars['target_dictionary_path'] = StringVar(value=config.get('target_dictionary_path'))
        ttk.Label(parent_frame, text="Path to Target Dictionary").pack(fill='x', padx=5, pady=(5,0))
        ttk.Entry(parent_frame, textvariable=property_vars['target_dictionary_path']).pack(fill='x', padx=5, pady=(0, 5))
        property_vars['key_to_upsert'] = StringVar(value=config.get('key_to_upsert'))
        ttk.Label(parent_frame, text="Key to Add/Update").pack(fill='x', padx=5, pady=(5,0))
        ttk.Entry(parent_frame, textvariable=property_vars['key_to_upsert']).pack(fill='x', padx=5, pady=(0, 5))
        property_vars['value_to_upsert'] = StringVar(value=config.get('value_to_upsert'))
        ttk.Label(parent_frame, text="Value to Set").pack(fill='x', padx=5, pady=(5,0))
        ttk.Entry(parent_frame, textvariable=property_vars['value_to_upsert']).pack(fill='x', padx=5, pady=(0, 5))
        ttk.Separator(parent_frame).pack(fill='x', pady=15, padx=5)
        debug_vars = shared_properties.create_debug_and_reliability_ui(parent_frame, config, self.loc)
        property_vars.update(debug_vars)
        loop_vars = shared_properties.create_loop_settings_ui(parent_frame, config, self.loc, available_vars)
        property_vars.update(loop_vars)
        return property_vars
    def get_data_preview(self, config: dict):
        return [{'status': 'preview not implemented'}]
